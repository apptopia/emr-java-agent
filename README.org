* EMR Java Agent: Solving Unbound Function Issue in Spark Executors

The EMR Java Agent is a package designed to address an issue encountered in scenarios like Spark executors, specifically the following error:

#+BEGIN_SRC
java.lang.IllegalStateException: Attempting to call unbound fn: #'xxx/fn1
	at clojure.lang.Var$Unbound.throwArity(Var.java:45)
	at clojure.lang.AFn.invoke(AFn.java:32)
	at xxx$fn2.invokeStatic(xxx.clj:7)
	at xxx$fn2.invoke(xxx.clj:6)
	at ...
#+END_SRC

** Usage

To utilize the EMR Java Agent, you need to add it as a Java agent. Here's how it's done using JVM options:

#+BEGIN_SRC shell-script
-javaagent:/path/to/emr-java-agent-1.0-SNAPSHOT.jar
#+END_SRC

Make sure to replace ~/path/to/emr-java-agent-1.0-SNAPSHOT.jar~ with the actual path to the agent JAR file.

** Apptopia-specific usage

[[https://github.com/apptopia/apptopia.emr][apptopia.emr]] enables this agent on spark clusters by default starting with ~f04b52a3a5f68dcf9619e2788818a8770bcdc1d7~.

*** Deploy

By default [[https://github.com/apptopia/apptopia.emr][apptopia.emr]] uses the following jar located in S3: ~s3://apptopia-emr/emr-java-agent-jars/emr-java-agent.jar~. You can use the following commands to deploy the agent to that location:

#+BEGIN_SRC shell
maven clean package
aws s3 cp 'target/emr-java-agent-1.0-SNAPSHOT.jar' 's3://apptopia-emr/emr-java-agent-jars/emr-java-agent.jar'
#+END_SRC

** Debugging

When working with the EMR Java Agent, you may encounter exceptions in two places:
 - In the agent code itself.
 - In the code generated by the agent.

If an exception occurs in the agent code, the agent will print a stack trace to stderr and terminate the application with an exit code of ~5~.

Exceptions in the generated code are usually ignored by default, as they may not impact execution but can be challenging to eliminate. However, you can enable debugging by setting the ~DEBUG_EMR_JAVA_AGENT~ variable.

When ~DEBUG_EMR_JAVA_AGENT~ is defined (the actual value doesn't matter), the agent will:
 - Print the class currently being processed by the agent.
 - Display stack traces of exceptions in the generated code.

* Understanding the Problem

Let's examine the problem by considering a Clojure namespace in your application:

#+BEGIN_SRC clojure
(ns xxx)

(defn fn1 [x]
  (+ x 1))

(defn fn2 [x]
  (fn1 x))
#+END_SRC

Suppose you want to map an RDD using ~fn2~:

#+BEGIN_SRC clojure
(->> (reify org.apache.spark.api.java.function.Function
       (call [_ item]
         (fn2 item)))
     (.map rdd))
#+END_SRC

However, when executing the job, the ~map~ task may fail when ~fn2~ attempts to invoke ~fn1~, leading to the unbound function error mentioned earlier:

#+BEGIN_SRC
java.lang.IllegalStateException: Attempting to call unbound fn: #'xxx/fn1
	at clojure.lang.Var$Unbound.throwArity(Var.java:45)
	at clojure.lang.AFn.invoke(AFn.java:32)
	at xxx$fn2.invokeStatic(xxx.clj:7)
	at xxx$fn2.invoke(xxx.clj:6)
	at ...
#+END_SRC

To understand why this happens, let's inspect the code for ~fn2~, which invokes ~fn1~ indirectly:

#+BEGIN_SRC
public final class xxx$fn2 extends clojure.lang.AFunction {
  public static final clojure.lang.Var const__0;

  public static java.lang.Object invokeStatic(java.lang.Object arg);
    Code:
          // return ((IFn) const__0.getRawRoot()).invoke(arg);
       0: getstatic     #15                 // Field const__0:Lclojure/lang/Var;
       3: invokevirtual #21                 // Method clojure/lang/Var.getRawRoot:()Ljava/lang/Object;
       6: checkcast     #23                 // class clojure/lang/IFn
       9: aload_0
          ...
      12: invokeinterface #26,  2           // InterfaceMethod clojure/lang/IFn.invoke:(Ljava/lang/Object;)Ljava/lang/Object;
      17: areturn

  public java.lang.Object invoke(java.lang.Object arg);
    Code:
          // return invokeStatic(arg);
       0: aload_1
          ...
       3: invokestatic  #30                 // Method invokeStatic:(Ljava/lang/Object;)Ljava/lang/Object;
       6: areturn

  public static {};
    Code:
          // const__0 = clojure.lang.RT.var("xxx", "fn1");
       0: ldc           #33                 // String xxx
       2: ldc           #35                 // String fn1
       4: invokestatic  #41                 // Method clojure/lang/RT.var:(Ljava/lang/String;Ljava/lang/String;)Lclojure/lang/Var;
       7: checkcast     #17                 // class clojure/lang/Var
      10: putstatic     #15                 // Field const__0:Lclojure/lang/Var;
      13: return
}
#+END_SRC

Notice that there is no direct reference to ~xxx$fn1~ (which represents ~fn1~) in this code. Instead, it accesses ~fn1~ using the ~#'xxx/fn1~ var, which must be bound to the actual function for successful execution.

In Clojure, all vars in a namespace are initialized when the namespace is loaded. Below is a simplified version of the initialization class for the ~xxx~ namespace, illustrating how ~#'xxx/fn1~ gets bound to the actual function during loading:

#+BEGIN_SRC
public class xxx__init {
  ...
  public static final clojure.lang.Var const__3;
  ...

  public static void load();
    Code:
          ...
          // const__3.bindRoot(new xxx$fn1());
      67: getstatic     #56                 // Field const__3:Lclojure/lang/Var;
          ...
      81: new           #67                 // class xxx$fn1
      84: dup
      85: invokespecial #68                 // Method xxx$fn1."<init>":()V
      88: invokevirtual #72                 // Method clojure/lang/Var.bindRoot:(Ljava/lang/Object;)V
          ...

  public static void __init0();
    Code:
          ...
          // const__3 = clojure.lang.RT.var("xxx", "fn1");
      37: ldc           #96                 // String xxx
      39: ldc           #104                // String fn1
      41: invokestatic  #94                 // Method clojure/lang/RT.var:(Ljava/lang/String;Ljava/lang/String;)Lclojure/lang/Var;
      44: checkcast     #12                 // class clojure/lang/Var
      47: putstatic     #56                 // Field const__3:Lclojure/lang/Var;
          ...

  public static {};
    Code:
          // __init0();
       0: invokestatic  #152                // Method __init0:()V
          ...
          // load();
      14: invokestatic  #171                // Method load:()V
          ...
}
#+END_SRC

When a Spark driver sends a task to a Spark executor, it serializes everything related to the task, including the function to be executed. However, the function itself doesn't load the namespace it belongs to, and neither does the executor. This behavior can be replicated by invoking ~fn2~ when the ~xxx~ namespace is not loaded:

#+BEGIN_SRC
repl> (.invoke (xxx$fn2.) 5)
Execution error (IllegalStateException) at xxx/fn2 (xxx.clj:7).
Attempting to call unbound fn: #'xxx/fn1
#+END_SRC

* A solution

Various solutions exist for this problem, such as [[https://clojure.org/reference/compilation#directlinking][direct linking]], loading specific namespaces on executor startup, or adding 'requires' to tasks themselves. The EMR Java Agent offers a solution by ensuring that namespaces are loaded when a class belonging to a namespace is loaded. It accomplishes this by adding the following line to the beginning of the static initialization block of every class associated with a namespace:

#+BEGIN_SRC clojure
(require '<namespace-of-the-class>)
#+END_SRC

This simple modification ensures that namespaces are loaded as needed and provides an effective solution to the unbound function issue. To implement this solution, you only need to make a minor adjustment to your executor's configuration.
